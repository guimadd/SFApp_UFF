A função insert() é definida dentro da estrutura Node, que representa um nó em uma árvore binária de busca (BST). A função tem o propósito de inserir elementos na árvore, seguindo uma lógica específica baseada na divisão de um array de frequências (freq) de caracteres. Aqui está um passo a passo detalhado do que a função faz:
  
  Calcula o Ponto de Divisão: A função começa calculando um ponto de divisão (slice) para o array de frequências fornecido, usando a função calcSlice(). Este ponto de divisão é calculado de forma a tentar dividir o array em duas partes que tenham somas de frequências aproximadamente iguais.
  
  Inserção à Esquerda:
  
  Cria um subarray aux contendo a primeira metade do array de frequências (até o ponto de divisão).
  Concatena os caracteres (data) desses elementos para formar o nome do novo nó à esquerda.
  Cria um novo nó à esquerda (this.left) com esse nome, um bit associado de 0, e sem filhos inicialmente.
  Se o subarray contém mais de um elemento, chama recursivamente insert(aux) para esse novo nó à esquerda, permitindo a construção da subárvore esquerda.
  Inserção à Direita:
  
  Repete um processo similar para a segunda metade do array de frequências (após o ponto de divisão), criando um subarray aux.
  Concatena os caracteres desses elementos para formar o nome do novo nó à direita.
  Cria um novo nó à direita (this.right) com esse nome, um bit associado de 1, e sem filhos inicialmente.
  Se o subarray contém mais de um elemento, chama recursivamente insert(aux) para esse novo nó à direita, permitindo a construção da subárvore direita.

A função calcSlice() é responsável por determinar o ponto ideal para dividir um array de frequências em duas partes, de modo a balancear a soma das frequências de cada lado. O objetivo é encontrar um ponto de corte onde a soma das frequências de um lado seja o mais próxima possível da metade da soma total das frequências. Isso é útil na construção da árvore Shannon-Fano, onde se busca minimizar a profundidade da árvore para obter uma codificação eficiente.

  Passo a passo do que a função faz:
  
  Calcula a soma total (total) das frequências de todos os elementos do array data.
  Inicializa uma variável soma com a frequência do primeiro elemento do array.
  Calcula a metade da soma total (halfTotal).
  Percorre o array data, começando do segundo elemento, e vai somando as frequências (soma) até que a adição da próxima frequência faça a soma ultrapassar halfTotal.
  Retorna o índice do último elemento que foi adicionado à soma sem ultrapassar halfTotal. Este índice é o ponto de corte sugerido para dividir o array em duas partes.

Função initDecode
  A função initDecode é responsável por inicializar o estado de decodificação com os dados necessários para decodificar uma string codificada em bits.
  
  Recebe dois parâmetros: bitCode, que é a string codificada em bits, e codes, que é um array de pares [caractere, código] representando o mapeamento de caracteres para seus respectivos códigos em bits.
  Inicializa o estado de decodificação (decodeState) com os seguintes campos:
  bitCode: Armazena a string codificada em bits recebida como parâmetro.
  codesObj: Transforma o array de códigos em um objeto para facilitar a busca durante a decodificação. Cada par [caractere, código] é invertido para [código, caractere], permitindo acessar diretamente o caractere correspondente a um código específico.
  tempCode: Uma string vazia que será usada para acumular bits até formar um código completo durante a decodificação.
  currentIndex: Um índice que aponta para a posição atual na string codificada em bits que está sendo processada.
  decodedString: Uma string vazia que armazenará o resultado da decodificação.

Função decodeStep
  A função decodeStep realiza um passo na decodificação da string codificada em bits, baseando-se no estado atual de decodificação armazenado em decodeState.
  
  Verifica se ainda há bits a serem processados comparando currentIndex com o comprimento da string codificada em bits (bitCode). Se ainda houver bits, o processo continua; caso contrário, a decodificação está completa.
  Acumula o próximo bit na string tempCode. Isso é feito adicionando o bit atual (indicado por currentIndex) de bitCode a tempCode.
  Verifica se tempCode corresponde a algum código conhecido no objeto codesObj. Se sim, realiza duas ações:
  Adiciona o caractere correspondente a tempCode (encontrado em codesObj) à string decodedString, que armazena o texto decodificado até o momento.
  Reseta tempCode para uma string vazia, preparando-a para acumular um novo código.
  Incrementa currentIndex para passar ao próximo bit na string codificada.
  Atualiza a interface do usuário (se necessário), mostrando a string decodificada até o momento e os bits restantes a serem processados. Isso é feito modificando o conteúdo de elementos HTML específicos, como o elemento com id bit_code, para refletir o progresso da decodificação.

A função calcSlice é responsável por determinar o ponto de divisão de um array de frequências para a construção de uma árvore binária, seguindo o princípio do algoritmo de Shannon-Fano. O objetivo é dividir o array de modo que a soma das frequências de um lado seja o mais próxima possível da soma das frequências do outro lado. Aqui está o passo a passo de como a função calcSlice opera:

  Calcular a soma total das frequências: A função itera sobre o array de dados data, que contém pares de caracteres e suas frequências, somando todas as frequências para obter o total.
  
  Encontrar o ponto de divisão: A função então busca o ponto onde a soma parcial das frequências, começando do início do array, é o mais próxima possível de metade da soma total das frequências. Isso é feito acumulando as frequências dos elementos um a um até que a soma parcial (incluindo o próximo elemento) ultrapasse a metade da soma total. O índice do elemento que causa essa condição é considerado o ponto de divisão.
  
  Retornar o índice de divisão: O índice encontrado é retornado pela função. Este índice é usado para dividir o array de frequências em dois subarrays: um à esquerda do ponto de divisão e outro à direita. Esses subarrays são então usados para construir os ramos esquerdo e direito da árvore binária, respectivamente.
  
  
  total é a soma total de todas as frequências.
  soma é a soma parcial das frequências, começando do primeiro elemento.
  halfTotal é metade da soma total das frequências.
  O loop for incrementa soma com a frequência do próximo elemento até que adicionar o próximo elemento faria soma exceder halfTotal.
  O índice j-1 é retornado, indicando o ponto de divisão onde o array deve ser dividido para tentar equilibrar as somas das frequências de ambos os lados.
